const Discord = require('discord.js');
const Database = require('./dbinfo.js');
const Messenger = require('./messenger.js');
const SQLQuery = require('./sqlquery.js');

const timeToWait = 30000;

exports.queryOngoing = false;

// Start the custom SQL query by asking for user input (top-level menu)
exports.startGeneralCollector = function(message, collectedInfo){

    let restrictionString; // List of restrictions imposed by the user

    // Build up the restriction text based on an array
    if(collectedInfo.length > 0)
    {
        restrictionString = "```\n";
        collectedInfo.forEach(val => {
            restrictionString += (val.Outer + " : " + val.Inner + " - " + val.Restriction + "\n");
        });
        restrictionString += "```";
    }

    // We store the promise generated by send() so we can delete the message later
    let queryMessage = message.channel.send("Preparing search query.\n" +
        "The current restrictions are:\n" +
        (restrictionString || "```NO RESTRICTIONS```") +
        "\nType in one of the following commands:\n" +
        "**add** - to add a restriction to the search\n" +
        "**remove** - to remove a restriction\n" +
        "**search** - to search with current restrictions\n" +
        "**cancel** - to cancel the query");

    // Start a new collector to look for keywords "add", "remove", "search", "cancel"
    let collector = new Discord.MessageCollector(message.channel, msg => {
        return msg.author.id === message.author.id; // Only messages from the original caller are registered
    }, { time : timeToWait });

    collector.on('collect', message => {

        if(message.content === "add") {
            collector.stop("add");
        }

        // Prevent calling of "remove" if there are no elements to remove
        else if(message.content === "remove") {
            if(collectedInfo.length === 0){
                message.channel.send("No conditions to remove!");
            }
            else{
                collector.stop("remove");
            }
        }

        else if(message.content === "search") {
            collector.stop("search");
        }

        else if(message.content === "cancel") {
            collector.stop("cancel");
        }
    });

    collector.on('end', (collected, reason) => {

        if(reason === "add"){ // Proceed onto the next level of collection
            queryMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));
            startOuterAddCollector(message, collectedInfo);
        }

        else if(reason === "remove"){ // Proceed onto the removal menu
            queryMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));
            startRemoveCollector(message, collectedInfo);
        }

        else if(reason === "search"){ // Search the database for the unit and output the result

            // Helper function to translate a user-input command to SQL
            function parseCond(cmd){
                let toReturn = "";
                ["EXACT MATCH", "ENDS WITH", "STARTS WITH", "CONTAINS"].forEach((val, ind) => {
                    if(cmd.indexOf(val) === 0) {
                        // cmd is a string
                        toReturn = [" = \"Q\"", " LIKE \"%Q\"", " LIKE \"Q%\"", " LIKE \"%Q%\""][ind]
                            .replace("Q", cmd.substring(val.length).trim());
                    }
                });
                ["GREATER THAN", "LESS THAN", "EQUAL TO"].forEach((val, ind) => {
                    if(cmd.indexOf(val) === 0) {
                        // cmd is a number
                        toReturn = [" > Q", " < Q", " = Q"][ind]
                            .replace("Q", cmd.substring(val.length).trim());
                    }
                });
                return toReturn;
            }

            // Form a query from the data that we have
            let query = ""; // Default SQL: "SELECT * FROM <tables>", query gets added to the default
            if(collectedInfo.length > 0){
                query += " WHERE ";
                while(collectedInfo.length > 1){
                    let data = collectedInfo.shift();
                    query += "UnitID IN (SELECT UnitID FROM " + data.Outer + " WHERE " + data.Inner +
                        parseCond(data.Restriction) + ") AND ";
                }
                let final = collectedInfo.shift(); // Do not add an AND after the final clause
                query += "UnitID IN (SELECT UnitID FROM " + final.Outer + " WHERE " + final.Inner +
                    parseCond(final.Restriction) + ")";
            }

            console.log("User queried SELECT * FROM [database]" + query);

            // Output the results to Discord
            SQLQuery.getUnitByQuery(query)
                .then(result => Messenger.processResults(message.channel, result))
                .catch(err => console.log(err));

            exports.queryOngoing = false;
        }

        else if(reason === "cancel"){ // Clean up and then output end reason
            queryMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));
            message.channel.send("The query builder has been cancelled.");
            exports.queryOngoing = false;
        }

        else if(reason === "time"){ // Clean up and then output end reason
            queryMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));
            message.channel.send("The query builder has timed out.");
            exports.queryOngoing = false;
        }
    });
};

// Helper function to remove restrictions based on user input
function startRemoveCollector(message, collectedInfo){
    // Build the output of restrictions from all collected info
    let restrictionString = "```\n";
    collectedInfo.forEach((val, ind) => {
        restrictionString += ("" + ind + ") " + val.Outer + " : "
            + val.Inner + " - " + val.Restriction + "\n");
    });
    restrictionString += "```";

    // We store the promise generated by send() so we can delete the message later
    let currentMessage = message.channel.send("Please input the number of the restriction you would like" +
        "to remove:" + restrictionString + "Otherwise, please input **cancel** to return.");

    // Start a new collector to look for numerical results or "cancel"
    let collector = new Discord.MessageCollector(message.channel, msg => {
        return msg.author.id === message.author.id;
    }, { time : timeToWait });

    collector.on('collect', message => {
        // If the input is a valid number within the list of restrictions
        if(!isNaN(message.content) &&
            +message.content >= 0 &&
            +message.content <= collectedInfo.length) {

            collectedInfo.splice(+message.content, 1); // Convert the input to a number and remove it
            collector.stop("complete")
        }

        else if(message.content === "cancel") {
            collector.stop("cancel");
        }
    });

    collector.on('end', (collected, status) => {
        // In either case, clean up and return back to the general collector.
        currentMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));
        exports.startGeneralCollector(message, collectedInfo);
    });
}

// Start the custom SQL query by asking for user input (second-level menu)
function startOuterAddCollector(message, collectedInfo){
    // We store the promise generated by send() so we can delete the message later
    let currentMessage = message.channel.send("Creating new restriction.\n" +
        "Please input the number of the table you would like to create the restriction in:" +
        "```\n" +
        "0 - General Unit Data (rarity, etc.)\n" +
        "1 - Unit Base Stats\n" +
        "2 - Unit Max Stats\n" +
        "3 - Unit Skills\n" +
        "4 - Unit Crash Skills\n" +
        "5 - Unit Ability 1\n" +
        "6 - Unit Ability 2\n" +
        "7 - Unit Ability 3\n" +
        "8 - Unit Ability 4\n" +
        "9 - Unit Ability 5```" + "Otherwise, please input **cancel** to return.");

    // Start a new collector to look for numerical results or "cancel"
    let collector = new Discord.MessageCollector(message.channel, msg => {
        return msg.author.id === message.author.id;
    }, { time : timeToWait });

    collector.on('collect', message => {
        // If the input is a valid number within our database bounds
        if(!isNaN(message.content) &&
            +message.content >= 0 &&
            +message.content <= Object.keys(Database).length) {
            collector.stop(Object.keys(Database)[+message.content]); // Pass the user input onwards
        }

        else if(message.content === "cancel") {
            collector.stop("cancel");
        }
    });

    collector.on('end', (collected, outerDB) => {
        // No matter what, clean up the message first
        currentMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));

        if(Database.hasOwnProperty(outerDB)){ //If the input is valid, move down a step
            startInnerAddCollector(message,collectedInfo, outerDB);
        }

        else if(outerDB === "cancel" || outerDB === "time"){
            // Return to the general collector, with extra info if it was a timeout
            message.channel.send((outerDB === "time" ? "Operation timed out. " : "")
                + "Returning back to general collector.");
            exports.startGeneralCollector(message, collectedInfo);
        }
    });
}

// Start the custom SQL query by asking for user input (third-level menu)
function startInnerAddCollector(message, collectedInfo, outer){
    // Build the list of possible options based on the selected table
    let possibilities = "```\n";
    Object.keys(Database[outer]).forEach((val, index) => {
        possibilities += ("" + index + " - " + val + "\n");
    });
    possibilities += "```";

    // We store the promise generated by send() so we can delete the message later
    let currentMessage = message.channel.send("Creating new restriction.\n" +
        "Please input the field of **" + outer + "** you would like to create the restriction in:" +
        possibilities + "Otherwise, please input **cancel** to return.");

    // Start a new collector to look for numerical results or "cancel"
    let collector = new Discord.MessageCollector(message.channel, msg => {
        return msg.author.id === message.author.id;
    }, { time : timeToWait });

    collector.on('collect', message => {
        if(!isNaN(message.content) &&
            +message.content >= 0 &&
            +message.content <= Object.keys(Database[outer]).length) {
            // If the input is a valid number within the table
            collector.stop(Object.keys(Database[outer])[+message.content]);
        }

        else if(message.content === "cancel") {
            collector.stop("cancel");
        }
    });

    collector.on('end', (collected, innerDB) => {
        // No matter what, clean up the message first
        currentMessage.then(msg => {return msg.delete();}).catch(err => console.log(err));

        if(Database[outer].hasOwnProperty(innerDB)){ //If the input is valid within the table
            startFinalAddCollector(message, collectedInfo, outer, innerDB);
        }

        else if(innerDB === "cancel" || innerDB === "time"){
            // Return to the general collector, with extra info if it was a timeout
            message.channel.send((innerDB === "time" ? "Operation timed out. " : "")
                + "Returning back to general collector.");
            exports.startGeneralCollector(message, collectedInfo);
        }
    });
}

// Start the custom SQL query by asking for user input (fourth-level menu)
function startFinalAddCollector(message,collectedInfo, outer, inner) {
    // Build the list of possible options based on whether the parameter is a string or number
    let possibilities = "```\n";
    if (typeof Database[outer][inner] === "string") {
        possibilities += "EXACT MATCH [text]\n" +
            "STARTS WITH [text]\n" +
            "ENDS WITH [text]\n" +
            "CONTAINS [text]";
    }
    else {
        possibilities += "GREATER THAN [number]\n" +
            "LESS THAN [number]\n" +
            "EQUAL TO [number]";
    }
    possibilities += "```";

    // We store the promise generated by send() so we can delete the message later
    let currentMessage = message.channel.send("Creating new restriction.\n" +
        "Please input the restriction you would like to impose on **" + outer + " : " + inner + "**:\n" +
        "This field is a " + (typeof Database[outer][inner] === "string" ? "word" : "number") + "," +
        " so your restrictions must be one of the following:\n" + possibilities
        + "Otherwise, please input **cancel** to return.");

    // Start a new collector to look for input that fits the restrictions
    let collector = new Discord.MessageCollector(message.channel, msg => {
        return msg.author.id === message.author.id;
    }, {time: timeToWait});

    collector.on('collect', message => {
        if (message.content === "cancel") {
            collector.stop("cancel");
        }

        else if (typeof Database[outer][inner] === "string") {
            let cmd = message.content.trim();
            ["EXACT MATCH", "ENDS WITH", "STARTS WITH", "CONTAINS"].forEach(val => {
                if (cmd.indexOf(val) === 0) {
                    collector.stop(cmd); // Only stop if the message is of the required format.
                }
            });
        }

        else if (typeof Database[outer][inner] === "number") {
            let cmd = message.content.trim();
            ["GREATER THAN", "LESS THAN", "EQUAL TO"].forEach(val => {
                if (cmd.indexOf(val) === 0) {
                    if (!isNaN(cmd.substring(val.length).trim())) { // Ensure the query is a number
                        collector.stop(cmd); // Only stop if the message is of the required format.
                    }
                }
            });
        }
    });

    collector.on('end', (collected, restriction) => {
        // No matter what, clean up the message first
        currentMessage.then(msg => { return msg.delete(); }).catch(err => console.log(err));

        if (restriction !== "cancel" && restriction !== "time") {
            // Add the new restriction to the collected info and return to the general collector
            collectedInfo.push({"Outer": outer, "Inner": inner, "Restriction": restriction});
            exports.startGeneralCollector(message, collectedInfo);
        }
        else {
            // Return to the general collector, with extra info if it was a timeout
            message.channel.send((restriction === "time" ? "Operation timed out. " : "")
                + "Returning back to general collector.");
            exports.startGeneralCollector(message, collectedInfo);
        }
    });
}